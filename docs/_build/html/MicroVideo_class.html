<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MicroVideo Class &mdash; SimpliPyTEM 0.1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PDF generator module" href="PDF_generator.html" />
    <link rel="prev" title="Micrograph Class" href="Micrograph_class.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> SimpliPyTEM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="SimpliPyTEM-GUI.html">SimpliPyTEM-GUI</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Micrograph_class.html">Micrograph Class</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">MicroVideo Class</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#list-of-functions-in-microvideo">List of functions in MicroVideo</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-MicroVideo_class">Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="PDF_generator.html">PDF generator module</a></li>
<li class="toctree-l1"><a class="reference internal" href="html_writer.html">HTML writer module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_analysis.html">Particle analysis module</a></li>
<li class="toctree-l1"><a class="reference internal" href="SimpliPyTEM-GUI.html">SimpliPyTEM-GUI</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SimpliPyTEM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">MicroVideo Class</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/MicroVideo_class.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="microvideo-class">
<h1>MicroVideo Class<a class="headerlink" href="#microvideo-class" title="Permalink to this headline"></a></h1>
<p>Module containing the class MicroVideo, this is the main tool of video analysis within the SimpliPyTEM package. The videos are loaded using one of the loading methods (open_dm or open_video), at which point the MicroVideo object contains the video data as a numpy array within the .frames attribute.  Many methods can be run with this object, including image filtering, converting to 8bit, improving contrast, plotting the image and the histogram.</p>
<p>The aim of this module was to make python-based analysis/basic enhancements of in situ TEM videos more simple by putting the majority of desired methods in a single package with simple commands.</p>
<p>This works in the same way as the Micrograph class but is designed for video data instead. As with the micrograph class, there are too many functions to include description of all here, beyond the autodoc documentation, however I recommend checking out the interactive jupyter notebook tutorial (tutorials/MicroVideoAnalysisTutorial.ipynb)</p>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline"></a></h2>
<p>Basic example including many of the functions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#Import module</span>
<span class="kn">from</span> <span class="nn">SimpliPyTEM.MicroVideo_class</span> <span class="kn">import</span> <span class="n">MicroVideo</span>

<span class="c1">#Initialise video</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">MicroVideo</span><span class="p">()</span>

<span class="c1">#Dpen video from Digital micrograph  file</span>
<span class="n">video</span><span class="o">.</span><span class="n">open_dm</span><span class="p">(</span><span class="s1">&#39;My_video.dm4&#39;</span><span class="p">)</span>

<span class="c1">#Bin video (reduce size)</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">#Gaussian filter (smooth) video</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">#Convert to 8bit (pixel values from 0-255)</span>
<span class="n">video</span><span class="o">.</span><span class="n">convert_to_8bit</span><span class="p">()</span>

<span class="c1">#Improve contrast</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">clip_contrast</span><span class="p">()</span>

<span class="c1">#Add a suitably sized scalebar</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">make_scalebar</span><span class="p">()</span>

<span class="c1">#Show the first frame</span>
<span class="n">video</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frame_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#Show an image of the average frame</span>
<span class="n">video</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">average</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1">#Average the video, combining 5 frames</span>
<span class="n">av</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">average_frames</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1">#Save video as mp4</span>
<span class="n">video</span><span class="o">.</span><span class="n">write_video</span><span class="p">(</span><span class="s1">&#39;Output.mp4&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that in each of these function examples I am overwriting the previous copy of the video by running (e.g.) video=video.bin() , can be desireable to reduce memorey use but you can also save them as separate to ensure you  keep the originals.</p>
</section>
<section id="list-of-functions-in-microvideo">
<h2>List of functions in MicroVideo<a class="headerlink" href="#list-of-functions-in-microvideo" title="Permalink to this headline"></a></h2>
<dl class="simple">
<dt>Imports:</dt><dd><ul class="simple">
<li><p>open_dm - Opening digital micrograph files</p></li>
<li><p>open_video - Opening a .mp4 or .avi video files</p></li>
<li><p>open_array - Loading a numpy array</p></li>
</ul>
</dd>
<dt>Saving:</dt><dd><ul class="simple">
<li><p>save_tif_stack</p></li>
<li><p>save_tif_sequence</p></li>
<li><p>write_video - save .mp4 or .avi version of the video</p></li>
<li><p>write_image - save video frame or video average as an image</p></li>
</ul>
</dd>
<dt>Basic functions:</dt><dd><ul class="simple">
<li><p>bin - reduce size of xy axis by binning pixels, factor is specified in call</p></li>
<li><p>convert_to_8bit - converts to 8bit video by scaling pixel values between 0-255.</p></li>
<li><p>make_scalebar  - creates suitably sized scalebar</p></li>
<li><p>Average_frames - averages frames in groups of n</p></li>
<li><p>Running_average - performs a running average of the video</p></li>
<li><p>reset_xy - reset the object x, y and shape attributes upon change of video, useful if video is cropped.</p></li>
</ul>
</dd>
<dt>Contrast enhancement:</dt><dd><ul class="simple">
<li><p>clip_contrast - enhances contrast by making a percentage of values saturated (absolute black/white) and scaling the rest of the pixels between these (my preferred contrast enhancement)</p></li>
<li><p>enhance_contrast - enhances contrast based on alpha (contrast), beta (brightness) and gamma (non-linear contrast) values</p></li>
<li><p>eqHist - equalises histogram, ensuring even converage of pixel values from 0-255</p></li>
<li><p>Normalise_video - normalises contrast between frames of the video</p></li>
</ul>
</dd>
<dt>Metadata (currently relies on dm3/dm4 metadata):</dt><dd><ul class="simple">
<li><p>show_metadata - shows all metadata tags and values</p></li>
<li><p>get_mag - prints and returns magnification (indicated and actual)</p></li>
<li><p>get_voltage - prints and returns voltage</p></li>
<li><p>get_exposure - prints and returns frame rate, exposure time</p></li>
<li><p>get_date_time - prints aquisition date and time</p></li>
</ul>
</dd>
<dt>Image filters:</dt><dd><ul class="simple">
<li><p>gaussian_filter</p></li>
<li><p>median_filter</p></li>
<li><p>low_pass_filter</p></li>
<li><p>weiner_filter</p></li>
<li><p>non_local_means_filter</p></li>
</ul>
</dd>
<dt>Plotting:</dt><dd><ul class="simple">
<li><p>imshow - plots still image (either single frame or average) of video</p></li>
<li><p>plot_histogram - plots the histogram of the video</p></li>
<li><p>show_video - shows video in a jupyter notebook (very slow)</p></li>
</ul>
</dd>
<dt>Other functions:</dt><dd><ul class="simple">
<li><p>Sidebyside - Sticks two videos together so they play side by side.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="module-MicroVideo_class">
<span id="documentation"></span><h2>Documentation<a class="headerlink" href="#module-MicroVideo_class" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">MicroVideo_class.</span></span><span class="sig-name descname"><span class="pre">MicroVideo</span></span><a class="headerlink" href="#MicroVideo_class.MicroVideo" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.Average_frames">
<span class="sig-name descname"><span class="pre">Average_frames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">groupsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_remainder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.Average_frames" title="Permalink to this definition"></a></dt>
<dd><p>Sums frames in groups, reducing the number of frames and the time resolution but increases contrast.</p>
<blockquote>
<div><dl class="simple">
<dt>Groupsize:int</dt><dd><p>Number of frames per group to average. Best as a multiple of the number of frames, else the final group will be the remainder (ie a 25 frame video split into groups of 10 will have 3 output frames: 1-10,11-20, 21-25 ).</p>
</dd>
<dt>keep_remainder: bool</dt><dd><p>Set to false to ignore the remainder when averaging (eg a 25 frame video split into sets of 10 leads to 2 frames, with the final 5 frames of the original being abandonned.)</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>SummedMicroVideo: Microvideo</dt><dd><p>Copy of the original video object with frames averaged in groups of {groupsize}</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.NLM_filter">
<span class="sig-name descname"><span class="pre">NLM_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.NLM_filter" title="Permalink to this definition"></a></dt>
<dd><p>Returns a non-local means filtered copy of the Microvideo, filter strength is defined in the call. 
More information on non-local means filtering can be found here: <a class="reference external" href="https://docs.opencv.org/3.4/d5/d69/tutorial_py_non_local_means.html">https://docs.opencv.org/3.4/d5/d69/tutorial_py_non_local_means.html</a></p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>h:int</dt><dd><p>Defines the strength of the Non-local means filter, default is 5</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>nlm_filtered_object<span class="classifier">Microvideo</span></dt><dd><p>Non-local means filtered copy of the Microvideo object</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.Normalise_video">
<span class="sig-name descname"><span class="pre">Normalise_video</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.Normalise_video" title="Permalink to this definition"></a></dt>
<dd><p>Normalises the video frames to have equal contrast, either through  mean or median normalisation</p>
<blockquote>
<div><dl class="simple">
<dt>normtype:str</dt><dd><p>options are mean or median - changes the type of normalisation, either the mean of each frame  is equal or the median of each frame is equal.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Normalised_microvideo: MicroVideo</dt><dd><p>Returns  a normalised copy of the original object.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.Running_average">
<span class="sig-name descname"><span class="pre">Running_average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">groupsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.Running_average" title="Permalink to this definition"></a></dt>
<dd><p>Sums frames in group of {groupsize} in a running or rolling average fashion - in this case these groups overlap with only a single frame offset, meaning the resulting video has (n - groupsize) frames.</p>
<blockquote>
<div><dl class="simple">
<dt>Groupsize:int</dt><dd><p>Number of frames per group to average. Best as a multiple of the number of frames, else the final group will be the remainder (ie a 25 frame video split into groups of 10 will have 3 output frames: 1-10,11-20, 21-25 ).</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>RunningAveragedMicrovideo:Microvideo</dt><dd><p>Copy of the original video object with frames averaged into groups of {groupsize} with a 1 frame offset between frames</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.Sidebyside">
<span class="sig-name descname"><span class="pre">Sidebyside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Video2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.Sidebyside" title="Permalink to this definition"></a></dt>
<dd><p>Joins a second video (in the form of a numpy array) to the original video, allowing them to be played side by side.</p>
<blockquote>
<div><dl class="simple">
<dt>Video2:np array</dt><dd><p>The second video to add to the original video</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>sidebyside:MicroVideo</dt><dd><p>Copy of the original video with the second video grafted onto the side.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.bin">
<span class="sig-name descname"><span class="pre">bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.bin" title="Permalink to this definition"></a></dt>
<dd><p>This function applies binning to the frames in a micrograph object, reducing their size by a specified factor.</p>
<dl class="simple">
<dt>value<span class="classifier">int</span></dt><dd><p>The factor by which to reduce the size of the frames. The default value is 2.</p>
</dd>
</dl>
<dl class="simple">
<dt>Microvideo_binned: MicroVideo</dt><dd><p>A new microvideo object with the binned frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.choose_scalebar_color">
<span class="sig-name descname"><span class="pre">choose_scalebar_color</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.choose_scalebar_color" title="Permalink to this definition"></a></dt>
<dd><p>Function for choosing the scalebar color and returns the pixelvalue and text color for the annotation.
Called through make_scalebar(), not a standalone function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.choose_scalebar_size">
<span class="sig-name descname"><span class="pre">choose_scalebar_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.choose_scalebar_size" title="Permalink to this definition"></a></dt>
<dd><p>Function for choosing scalebar size, called through make_scalebar(), not a standalone function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.clip_contrast">
<span class="sig-name descname"><span class="pre">clip_contrast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.clip_contrast" title="Permalink to this definition"></a></dt>
<dd><p>Function for enhancing the contrast in an image by clipping the histogram between two values. 
These values can be defined directly or can be automatically decided using a saturation value, which the is percentage of the pixels above or below this value.
I.e, if there are 1,000,000 pixels in an image and the saturation value is 0.1, the method searches the value for which only 0.1% or 1000 pixels are above/below. 
These values then become the new minimum and maximum of the image, and are scaled to between 0 and 255.</p>
<p>This method will automatically convert to 8 bit (scale between 0 and 255), if this is an issue raise and it can be changed in future versions.</p>
<blockquote>
<div><dl class="simple">
<dt>saturation: Float</dt><dd><p>The percentage cutoff above/below which the pixels are set to zero/255, default is 0.5% of pixels</p>
</dd>
<dt>maxvalue: int</dt><dd><p>The maximum value that is being clipped (to be decided from histogram). Optional.</p>
</dd>
<dt>minvalue: int</dt><dd><p>The minimum value that is being clipped (to be decided from histogram). Optional.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Contrast_enhanced_microvideo<span class="classifier">Microvideo</span></dt><dd><p>Return a copy of the object with the contrast clipped at either end of the image</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>MicrovideoContrastClipped = video.clip_contrast(saturation=1)</p>
<p>or</p>
<p>MicrovideoContrastClipped = video.clip_contrast(maxvalue=220, minvalue=20)</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.convert_to_8bit">
<span class="sig-name descname"><span class="pre">convert_to_8bit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.convert_to_8bit" title="Permalink to this definition"></a></dt>
<dd><p>Returns a microvideo object with the image scaled between 0 and 255 (an 8-bit image). Improves contrast, reduces data size and is a more usable image format than higher bit rates.</p>
<blockquote>
<div><dl class="simple">
<dt>MicroVideo8bit<span class="classifier">MicroVideo</span></dt><dd><p>A copy of the microvideo object with the image scaled between 0 and 255</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.enhance_contrast">
<span class="sig-name descname"><span class="pre">enhance_contrast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.enhance_contrast" title="Permalink to this definition"></a></dt>
<dd><p>Function for enhancing contrast. This uses the OpenCV methods detailed here: <a class="reference external" href="https://docs.opencv.org/3.4/d3/dc1/tutorial_basic_linear_transform.html">https://docs.opencv.org/3.4/d3/dc1/tutorial_basic_linear_transform.html</a>. 
There are 3 input values which define contast controls: alpha, beta and gamma, the gamma value is optional.</p>
<blockquote>
<div><dl class="simple">
<dt>alpha:float</dt><dd><p>Basic contrast control, usually in the range of 1-3. The histogram is streched.</p>
</dd>
<dt>beta: int (or float)</dt><dd><p>Brightness control, this will add the value to every pixel in the image, only really has an effect with 8-bit images (and any pixels above 255 will be clipped to this)</p>
</dd>
<dt>gamma:float</dt><dd><p>Non-linear contrast control, values between 0-1 makes images brighter (particularly the dark areas), while values &gt;1 darken the image(particularly the bright areas)
Optional, if included image will be converted to 8 bit.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Contrast_enhanced_microvidoe<span class="classifier">MicroVideo</span></dt><dd><p>Return a copy of the object with the contrast enhanced.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.eqHist">
<span class="sig-name descname"><span class="pre">eqHist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.eqHist" title="Permalink to this definition"></a></dt>
<dd><p>Spreads the contrast across complete range of values, leading to an evened, flattened histogram. This can be very effective at enhancing midtones in images with very bright or very dark patches.</p>
<blockquote>
<div><dl class="simple">
<dt>Contrast_enhanced_microvideo<span class="classifier">MicroVideo</span></dt><dd><p>Return a copy of the object with the contrast enhanced.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.gaussian_filter">
<span class="sig-name descname"><span class="pre">gaussian_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.gaussian_filter" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Gaussian filtered copy of the micrograph object, kernal size defined in the call (default is 3)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>n:int</dt><dd><p>The n x n kernal for median filter is defined here, <em>must be an odd integer</em></p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Gaussian_filtered_object :Micrograph</dt><dd><p>Gaussian filtered copy of micrograph object with gaussian filtered image</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.get_date_time">
<span class="sig-name descname"><span class="pre">get_date_time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.get_date_time" title="Permalink to this definition"></a></dt>
<dd><p>Prints and returns the aquisition date and time for the image.</p>
<blockquote>
<div><dl class="simple">
<dt>AqDate:str</dt><dd><p>Date on which the micrograph was captured</p>
</dd>
<dt>AqTime:str</dt><dd><p>Time at which the micrograph was captured</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.get_exposure">
<span class="sig-name descname"><span class="pre">get_exposure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.get_exposure" title="Permalink to this definition"></a></dt>
<dd><p>Prints and returns the frame rate, exposure time per frame, imaging time and number of frames.</p>
<blockquote>
<div><dl class="simple">
<dt>fps:int</dt><dd><p>Frame rate of the video in frames per second</p>
</dd>
<dt>Imaging_time:int</dt><dd><p>The total imaging time for the video. s</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.get_mag">
<span class="sig-name descname"><span class="pre">get_mag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.get_mag" title="Permalink to this definition"></a></dt>
<dd><p>Returns Micrograph magnifications (indicated and actual) and saves them as microvideo attributes (microscope.indicated_mag, microscope.actual_mag)</p>
<blockquote>
<div><dl class="simple">
<dt>indicated_mag:float</dt><dd><p>Indicated magnification (i.e. what the microscope tells you the mag is) for the image</p>
</dd>
<dt>actual_mag: float</dt><dd><p>Actual magnification of the image at the camera.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.get_voltage">
<span class="sig-name descname"><span class="pre">get_voltage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.get_voltage" title="Permalink to this definition"></a></dt>
<dd><p>Returns voltage and saves is as micrograph attribute</p>
<blockquote>
<div><dl class="simple">
<dt>Voltage:int</dt><dd><p>Microscope voltage for the image</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.imshow">
<span class="sig-name descname"><span class="pre">imshow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">framenumber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.imshow" title="Permalink to this definition"></a></dt>
<dd><p>Method to view the video as a static image. This method completely uses matplotlib’s imshow function to show the image, however this allows control of display with a single command.</p>
<p>This method allows control of the title, whether the image is averaged, which frame is plotted and the maximum and minimum values plotted.</p>
<blockquote>
<div><dl class="simple">
<dt>title:str</dt><dd><p>This gives a title to the plot.</p>
</dd>
<dt>vmax:int or float</dt><dd><p>The maximum value in the image such that any value above vmax is white.</p>
</dd>
<dt>vmin: int or float</dt><dd><p>The minimum value in the image such that any value below vmin is black.</p>
</dd>
<dt>framenumber: int</dt><dd><p>The index of the frame to be shown (starting from zero, minus numbers can also count from the final frame, i.e -1 is the final frame). If the frame number is out of range, an IndexError is raised.</p>
</dd>
<dt>average: bool </dt><dd><p>Setting to True shows an average of all the frames of the video rather than individual frame number</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.imshow_pair">
<span class="sig-name descname"><span class="pre">imshow_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.imshow_pair" title="Permalink to this definition"></a></dt>
<dd><p>Basic function for plotting 2 stills from videos side by side. this</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.low_pass_filter">
<span class="sig-name descname"><span class="pre">low_pass_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.low_pass_filter" title="Permalink to this definition"></a></dt>
<dd><p>This low pass filters the image. The pixel size is used to scale the radius to whatever the pixel unit is (ie radius 10 is 10nm/10um)
If pixelsize is undefined the radius will refer to pixels only</p>
<blockquote>
<div><dl>
<dt>radius<span class="classifier">int (or potentially float)</span></dt><dd><dl>
<dt>The effects of this vary depending on if the pixelsize is defined in self.pixelSize.: </dt><dd><blockquote>
<div><ul class="simple">
<li><p>Assuming your micrograph object has a pixel size defined, the filter works by removing any features smaller than the size you input as a parameter (the unit is the same as the pixelsize), A larger number yields a stronger filter, if it is too large, you won’t see any features.</p></li>
</ul>
</div></blockquote>
<p>Effective filter sizes depends on features and magnification, so with something between 1-5 and tune it to your needs.
- If your micrograph is missing a pixelsize the size input will be the radius of a circle kept in the power spectrum. Here the input number does the inverse - a smaller number leads to stronger filter. In this case, much larger numbers will be needed, 50 is a good starting value.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Low_pass_filtered_object :MicroVideo</dt><dd><p>Low pass filtered copy of the microvideo object.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.make_scalebar">
<span class="sig-name descname"><span class="pre">make_scalebar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">texton</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Auto'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.make_scalebar" title="Permalink to this definition"></a></dt>
<dd><p>Automated method to create a scalebar of a suitable size, shape and color. Returns a new object with a scalebar. 
The color will be selected between black and white based on mean value of the region of the scalebar compared to the mean value of the whole video. To override this the color can be defined as black white or grey.
This will work best for 8-bit images, as the scalebar will be given values of 0 or 255.</p>
<blockquote>
<div><dl class="simple">
<dt>color<span class="classifier">str</span></dt><dd><p>The color of the scalebar, the options are ‘white’. ‘black’ or ‘grey’</p>
</dd>
<dt>texton<span class="classifier">bool</span></dt><dd><p>Text can be turned off using texton=False, the selected size of the scalebar can be accessed using micrograph.scalebar_size</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Micrograph_object_with_scalebar: Micrograph</dt><dd><p>Copy of the micrograph object with a scale bar.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.median_filter">
<span class="sig-name descname"><span class="pre">median_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.median_filter" title="Permalink to this definition"></a></dt>
<dd><p>Returns a median filtered copy of the Microvideo object, kernal size defined in the call (default is 3)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>kernal:int</dt><dd><p>The n x n kernal for median filter is defined here, must be an odd integer</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Median_filtered_object :Microvideo</dt><dd><p>Median filtered copy of Microvideo object with median filtered image</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.motioncorrect_vid">
<span class="sig-name descname"><span class="pre">motioncorrect_vid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.motioncorrect_vid" title="Permalink to this definition"></a></dt>
<dd><p>This is tricky to use but can be incredibly effective, motioncorrecting LTEM videos can dramatically improve the signal to noise ratio of outputted averages. 
Here I use the publically available software motioncor2, which can be downloaded from here: <a class="reference external" href="https://emcore.ucsf.edu/ucsf-software">https://emcore.ucsf.edu/ucsf-software</a> which can correct for motion within the video.</p>
<p>In order to use this function, you need to download this software, and then set a path to the executable, note that several versions will be downloaded so ensure you use the correct one for your CUDA setup, I believe CUDA is required for this.</p>
<dl class="simple">
<dt>to set the executable, open terminal and type: </dt><dd><p><code class="docutils literal notranslate"><span class="pre">`export</span> <span class="pre">MOTIONCOR2_PATH='PATH/TO/EXECUTABLE'`</span></code></p>
</dd>
</dl>
<p>to give an example of what this looks like, this is how it looks on my computer:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`export</span> <span class="pre">MOTIONCOR2_PATH='/home/Gabriel/Downloads/MotionCor2_1.4.4/MotionCor2_1.4.4_Cuda113-08-11-2021'`</span></code></p>
</div></blockquote>
<p>To avoid needing to do this for every new terminal opened, add this line to your .bashrc file in your home directory (you can use the terminal text editor nano for this: <code class="docutils literal notranslate"><span class="pre">`nano</span> <span class="pre">~/.bashrc`</span></code>)</p>
<p>After doing this, the function should hopefully work, just use:</p>
<blockquote>
<div><p>video=MicroVideo()
video.open_dm(‘myfile.dm4’)
motioncorrected_vid = video.motioncorrect_vid()</p>
</div></blockquote>
<blockquote>
<div><p>MotionCorrected_video_object:</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.open_array">
<span class="sig-name descname"><span class="pre">open_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixelsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixelunit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Loaded_array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.open_array" title="Permalink to this definition"></a></dt>
<dd><p>Loads a numpy array into the microvideo object, allowing use of all the other available methods. Filename, pixel size and pixel unit should be given in the call, defaults of 1nm/pixel allow this to be avoided but correct pixel size should be loaded if a scalebar is required (as well as certain other functions)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.open_dm">
<span class="sig-name descname"><span class="pre">open_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixelcorrection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.open_dm" title="Permalink to this definition"></a></dt>
<dd><p>Imports digital micrograph files into the micrograph object, initialising all the default attributes required, including saving the metadata into self.metadata_tags. 
By default, video dm files (dose fractionations) will be summed to create a single image file, there is also an option (video_average) to use the first frame only.</p>
<p>Some DM files have ‘hot pixels’ which have anomalously high signal due to detector malfunction, these often lead to contrast issues.
To correct for this any pixel which has a higher value than the mean value + (20 x standard deviation) is set to the mean pixel value, this is on by default but can be turned off using pixel_correction=False</p>
<p>This uses the ncempy.io.dm package to read DM files, more information can be found here: <a class="reference external" href="https://openncem.readthedocs.io/en/latest/ncempy.io.html">https://openncem.readthedocs.io/en/latest/ncempy.io.html</a></p>
<blockquote>
<div><dl class="simple">
<dt>file<span class="classifier">str</span></dt><dd><p>The name of the dm file to open. The path to the file can also be included if it is not in the same directory.</p>
</dd>
<dt>pixel_correction: bool </dt><dd><p>Set anomalous ‘hot’ pixels to the image mean, anomalous pixels defined as image_mean + 20*image_standard_deviation. Default is on (True).</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.open_series">
<span class="sig-name descname"><span class="pre">open_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frames</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.open_series" title="Permalink to this definition"></a></dt>
<dd><p>Hasn’t exactly been tested but should work!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.open_video">
<span class="sig-name descname"><span class="pre">open_video</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixelsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixelunit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nm'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.open_video" title="Permalink to this definition"></a></dt>
<dd><p>Loads video files (eg. mp4 and avi, unsure if others will work) into microvideo object.
The pixel size is not taken from the video by default, and so it should be included in the command, else the default of 1nm/pixel is used. This can be addedd later using video.pixelSize= {new pixel size}</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.pixel_size">
<span class="sig-name descname"><span class="pre">pixel_size</span></span><a class="headerlink" href="#MicroVideo_class.MicroVideo.pixel_size" title="Permalink to this definition"></a></dt>
<dd><p>SECTION: IMPORT IMAGES</p>
<blockquote>
<div><p>can be imported as dm3, dm4, mrc, <a href="#id1"><span class="problematic" id="id2">**</span></a>numpy array or tifs ** add the tifs 
need to add numpy and tif functionality</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.plot_histogram">
<span class="sig-name descname"><span class="pre">plot_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sidebyside</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imAverage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">histAverage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.plot_histogram" title="Permalink to this definition"></a></dt>
<dd><p>Plots the histogram of the video (or average of the video), this an be accompanied by either the first frame of the video or the sum of the video frames.</p>
<blockquote>
<div><dl>
<dt>sidebyside:bool</dt><dd><p>plots the histogram beside a still image of the video - either first frame or image sum</p>
</dd>
<dt>imAverage:bool </dt><dd><p>if plotting a still, this determines whether the still is the video sum (average) or the first frame, true for video sum.</p>
</dd>
<dt>histAverage:bool</dt><dd><blockquote>
<div><p>Plot the histogram of the average frame? (True) or the histogram of the whole video (False)</p>
</div></blockquote>
<dl class="simple">
<dt>vmax:int or float</dt><dd><p>The maximum value in the sidebyside plotted image such that any value above vmax is white.</p>
</dd>
</dl>
</dd>
<dt>vmin: int or float</dt><dd><p>The minimum value in the sidebyside plotted image such that any value below vmin is black.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>Plots the histogram of the video, can have a video still beside the histogram.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.reset_xy">
<span class="sig-name descname"><span class="pre">reset_xy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.reset_xy" title="Permalink to this definition"></a></dt>
<dd><p>Resets the image attributes for the x, y and shape of the image. Used by the binning method and is also useful following cropping of the micrograph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.save_tif_sequence">
<span class="sig-name descname"><span class="pre">save_tif_sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.save_tif_sequence" title="Permalink to this definition"></a></dt>
<dd><p>Saves each frame of the video as a tif, this is saved in the current format, so if an 8bit tif is required, run video.convert_to_8bit() before use.
nameand outdir can be included to give a name (prefix) and  the output directory.</p>
<blockquote>
<div><dl class="simple">
<dt>name:str</dt><dd><p>Prefix for the outputted filenames.</p>
</dd>
<dt>outdir:str</dt><dd><p>The output directory for the files, if this directory doesn’t exist (in the cwd) a new one will be created.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>Saves a sequence of Tif files into the output directory listed (cwd is default)</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.save_tif_stack">
<span class="sig-name descname"><span class="pre">save_tif_stack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.save_tif_stack" title="Permalink to this definition"></a></dt>
<dd><p>Saves the video as a single, multi-image tif file (stack). Files saved in current condition so if an 8bit tif is required, run video.convert_to_8bit() before use.
These can be useful for viewing editted video in imageJ</p>
<blockquote>
<div><dl class="simple">
<dt>name:str</dt><dd><p>Prefix for the outputted filename.</p>
</dd>
<dt>outdir:str</dt><dd><p>The output directory for the files, if this directory doesn’t exist (in the cwd) a new one will be created.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>Saves a multi-image tif stack into the output directory listed (cwd is default)</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.show_metadata">
<span class="sig-name descname"><span class="pre">show_metadata</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.show_metadata" title="Permalink to this definition"></a></dt>
<dd><p>prints the metadata tags, this can be useful for finding the names of metadata features within the metadata.tags file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.show_video">
<span class="sig-name descname"><span class="pre">show_video</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.show_video" title="Permalink to this definition"></a></dt>
<dd><p>Method to show the video within a jupyter notebook.</p>
<blockquote>
<div><dl class="simple">
<dt>fps: int</dt><dd><p>The frame rate of the video show (in frames per second), default is to take it from the metadata, and failing that show it at 10fps.</p>
</dd>
<dt>vmax:int or float</dt><dd><p>The maximum value in the image such that any value above vmax is white.</p>
</dd>
<dt>vmin: int or float</dt><dd><p>The minimum value in the image such that any value below vmin is black.</p>
</dd>
<dt>reduce size: int</dt><dd><p>Factor to reduce size when plotting the video, this is important to add for large videos to reduce the time to plot the video.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.toMicrograph">
<span class="sig-name descname"><span class="pre">toMicrograph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.toMicrograph" title="Permalink to this definition"></a></dt>
<dd><p>Returns a micrograph object with the average of the image so the video average can be treated as a single image</p>
<blockquote>
<div><dl class="simple">
<dt>micrograph:Micrograph</dt><dd><p>Micrograph object with the same metadata and an average of all the image frames.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.weiner_filter">
<span class="sig-name descname"><span class="pre">weiner_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.weiner_filter" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Weiner filtered copy of the Microvideo object, kernal size defined in the call (default is 5)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>n :int</dt><dd><p>The n x n kernal for Weiner filter is defined here, must be an odd integer</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>Weiner_filtered_object<span class="classifier">Microvideo</span></dt><dd><p>Weiner filtered copy of Microvideo object</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.write_image">
<span class="sig-name descname"><span class="pre">write_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ftype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'jpg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">framenumber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.write_image" title="Permalink to this definition"></a></dt>
<dd><p>Saves the image in a .jpg or .tif file for display or use with other programs.</p>
<blockquote>
<div><dl class="simple">
<dt>name: str</dt><dd><p>Filename for saved image. Ending with either .jpg or .tif will define the format of the image, alternatively ftype argument can be used. 
This is optional, without including a name the name of the original file opened will be used.</p>
</dd>
<dt>ftype: str</dt><dd><p>Optional. Filetype of output image, either ‘jpg’ or ‘tif’ (default jpg), this is better defined using the suffix of the name. 
Saving as a tif will save in whatever format it is currently in - this can be a 32-bit or 8-bit image, using convert_to_8bit() will ensure that latter.</p>
</dd>
<dt>outdir: str</dt><dd><p>Keyword argument (usage: outdir=’/path/to/directory’). This defines the output location of the saved image, use a path relative to the current directory or an absolute path.
The final directory in the path will be made if it does not already exist.</p>
</dd>
<dt>average:bool</dt><dd><p>Do you want to save an image of the average of the video? True or False (y/n)</p>
</dd>
<dt>framenumber:int</dt><dd><p>If not saving the average (average=False), this chooses which frame to save - index starts at zero and negative numbers count from the end</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="MicroVideo_class.MicroVideo.write_video">
<span class="sig-name descname"><span class="pre">write_video</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.MicroVideo.write_video" title="Permalink to this definition"></a></dt>
<dd><p>This allows saving as an mp4 or a raw avi file (imageJ compatible)</p>
<blockquote>
<div><dl class="simple">
<dt>name:str</dt><dd><p>Output filename. Outputted files can be in mp4 or uncompressed avi (imageJ readable) filetypes (mp4 by default), this is denoted by the suffix of the name.</p>
</dd>
<dt>outdir:str</dt><dd><p>The output directory for the files, if this directory doesn’t exist (in the cwd) a new one will be created.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>Saves a sequence of Tif files into the output directory listed (cwd is default)</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="MicroVideo_class.default_video_pipeline">
<span class="sig-prename descclassname"><span class="pre">MicroVideo_class.</span></span><span class="sig-name descname"><span class="pre">default_video_pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">medfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalebar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xybin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Average_frames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#MicroVideo_class.default_video_pipeline" title="Permalink to this definition"></a></dt>
<dd><p>Use to automate default filtering, scalebar adding, binning,frame averaging and saving.</p>
<p>From a coding point of view this function is a bit of a mess with if…elif…else statements so I should clear it up at some point.</p>
<blockquote>
<div><dl class="simple">
<dt>filename: str</dt><dd><p>The filename of the .dm3 or .dm4 file to open</p>
</dd>
<dt>output type: str</dt><dd><p>This needs to be one of the following: [‘Save Average’, ‘Save Tif Stack’, ‘Save Tif Sequence’, ‘Save Video as .mp4’, ‘Save video as .avi’, ‘Save MotionCorrected Average’]</p>
</dd>
<dt>medfilter: int</dt><dd><p>Kernal value for a median filter to apply, zero is no filter</p>
</dd>
<dt>gaussfilter: int</dt><dd><p>Kernal for a gaussian filter to apply, zero is no filter</p>
</dd>
<dt>xybin: int</dt><dd><p>value by which the image is binned (reduced size) on both the x and y axis</p>
</dd>
<dt>scalebar:bool</dt><dd><p>True for adding scalebar, False for not adding scalebar</p>
</dd>
<dt>Average_frames: int</dt><dd><p>Average this number of frames together, only used for saving as video options.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>Performs filtering etc as parameters suggest, saves it in format defined in output_type.</p>
</div></blockquote>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Micrograph_class.html" class="btn btn-neutral float-left" title="Micrograph Class" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="PDF_generator.html" class="btn btn-neutral float-right" title="PDF generator module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Gabriel Ing.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>